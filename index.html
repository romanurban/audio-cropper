<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Chunking Editor</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        
        .container {
            background: #2d2d2d;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #4CAF50;
        }
        
        .upload-area {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        
        .upload-area:hover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .upload-area.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        
        .upload-btn:hover {
            background: #45a049;
        }
        
        .waveform-container {
            margin: 20px 0;
            background: #333;
            border-radius: 8px;
            padding: 20px;
            display: none;
        }
        
        .waveform {
            height: 200px;
            background: #444;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }
        
        .waveform canvas {
            width: 100%;
            height: 100%;
        }
        
        .selection {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
            pointer-events: none;
        }
        
        .chunk-overlay {
            position: absolute;
            top: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .chunk-overlay.selected {
            background: rgba(255, 107, 107, 0.2);
            border-color: #FF6B6B;
            opacity: 1;
        }
        
        .chunk-overlay.hovered {
            opacity: 1;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #45a049;
        }
        
        .btn-secondary {
            background: #666;
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #777;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #da190b;
        }
        
        .btn-warning {
            background: #ff9800;
            color: white;
        }
        
        .btn-warning:hover:not(:disabled) {
            background: #f57c00;
        }
        
        .info {
            margin-top: 15px;
            padding: 10px;
            background: #444;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .info .chunk-info {
            margin-top: 8px;
            padding: 8px;
            background: #555;
            border-radius: 4px;
            border-left: 3px solid #FF6B6B;
        }
        
        .progress {
            margin-top: 10px;
            height: 4px;
            background: #555;
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .instructions {
            margin-top: 10px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 4px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Audio Chunking Editor</h1>
        
        <div class="upload-area" id="uploadArea">
            <p>Drag & drop an audio file here or click to browse</p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                Choose Audio File
            </button>
            <input type="file" id="fileInput" accept="audio/*">
        </div>
        
        <div class="waveform-container" id="waveformContainer">
            <div class="waveform" id="waveform">
                <canvas id="waveformCanvas"></canvas>
                <div class="selection" id="selection" style="display: none;"></div>
            </div>
            
            <div class="instructions">
                üéØ <strong>Click</strong> on waveform to seek | üé® <strong>Drag</strong> to select region | ‚úÇÔ∏è <strong>Split</strong> at seek position | üñ±Ô∏è <strong>Click chunks</strong> to select them
            </div>
            
            <div class="controls">
                <button class="btn btn-primary" id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
                <button class="btn btn-secondary" id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
                <button class="btn btn-secondary" id="stopBtn" disabled>‚èπÔ∏è Stop</button>
                <button class="btn btn-warning" id="splitBtn" disabled>‚úÇÔ∏è Split at Position</button>
                <button class="btn btn-primary" id="cropBtn" disabled>üìè Crop Selection</button>
                <button class="btn btn-danger" id="deleteBtn" disabled>üóëÔ∏è Delete</button>
            </div>
            
            <div class="info" id="info">
                <div>Duration: <span id="duration">--:--</span></div>
                <div>Current Time: <span id="currentTime">--:--</span></div>
                <div>Selection: <span id="selectionInfo">No selection</span></div>
                <div>Chunks: <span id="chunkCount">1</span></div>
                <div class="chunk-info" id="chunkInfo" style="display: none;">
                    <strong>Selected Chunk:</strong> <span id="selectedChunkInfo">None</span>
                </div>
            </div>
            
            <div class="progress" id="progress">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
    </div>

    <script>
        class AudioChunkingEditor {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.source = null;
                this.isPlaying = false;
                this.playStartTime = 0;
                this.pausedAtTime = 0;
                this.selection = { start: 0, end: 0 };
                this.waveformData = null;
                this.isDragging = false;
                this.dragStarted = false;
                this.originalFile = null;
                this.isInitialized = false;
                this.seekPosition = 0;
                
                // Chunk management
                this.chunks = [{ start: 0, end: 0, id: 0 }]; // Will be set when audio loads
                this.selectedChunk = null;
                this.chunkOverlays = [];
                this.nextChunkId = 1;
                
                // Playback state
                this.currentlyPlayingChunk = null;
                this.playingChunks = null;
                this.playingStartOffset = 0;
                
                this.initializeElements();
                this.setupEventListeners();
            }
            
            initializeElements() {
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.waveformContainer = document.getElementById('waveformContainer');
                this.waveform = document.getElementById('waveform');
                this.canvas = document.getElementById('waveformCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.selectionDiv = document.getElementById('selection');
                this.playBtn = document.getElementById('playBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.splitBtn = document.getElementById('splitBtn');
                this.cropBtn = document.getElementById('cropBtn');
                this.deleteBtn = document.getElementById('deleteBtn');
                this.durationSpan = document.getElementById('duration');
                this.currentTimeSpan = document.getElementById('currentTime');
                this.selectionInfo = document.getElementById('selectionInfo');
                this.chunkCount = document.getElementById('chunkCount');
                this.chunkInfo = document.getElementById('chunkInfo');
                this.selectedChunkInfo = document.getElementById('selectedChunkInfo');
                this.progress = document.getElementById('progress');
                this.progressBar = document.getElementById('progressBar');
            }
            
            setupEventListeners() {
                // File upload
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Drag and drop
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.add('dragover');
                });
                
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.classList.remove('dragover');
                });
                
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFile(files[0]);
                    }
                });
                
                // Waveform interaction
                this.waveform.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.waveform.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.waveform.addEventListener('mouseup', () => this.handleMouseUp());
                this.waveform.addEventListener('mouseleave', () => this.handleMouseUp());
                this.waveform.addEventListener('click', (e) => this.handleWaveformClick(e));
                
                // Controls
                this.playBtn.addEventListener('click', () => this.play());
                this.pauseBtn.addEventListener('click', () => this.pause());
                this.stopBtn.addEventListener('click', () => this.stop());
                this.splitBtn.addEventListener('click', () => this.splitAtPosition());
                this.cropBtn.addEventListener('click', () => this.cropAudio());
                this.deleteBtn.addEventListener('click', () => this.delete());
                
                // Resize
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            handleWaveformClick(event) {
                // Don't allow chunk selection if there's only one chunk
                if (this.chunks.length <= 1) {
                    return;
                }
                
                // Check if click is on a chunk
                const rect = this.waveform.getBoundingClientRect();
                const x = event.clientX - rect.left;
                
                // Calculate which chunk was clicked based on proportional layout
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4; // pixels between chunks
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const availableWidth = rect.width - totalGaps;
                
                let currentX = 0;
                let clickedChunk = null;
                
                for (const chunk of this.chunks) {
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidth = availableWidth * chunkWidthRatio;
                    
                    // Check if click is within this chunk's bounds
                    if (x >= currentX && x <= currentX + chunkWidth) {
                        clickedChunk = chunk;
                        break;
                    }
                    
                    // Move to next chunk position (add gap)
                    currentX += chunkWidth + gapWidth;
                }
                
                if (clickedChunk) {
                    this.selectChunk(clickedChunk);
                }
            }
            
            selectChunk(chunk) {
                this.selectedChunk = chunk;
                this.updateChunkOverlays();
                this.updateChunkInfo();
                this.updateDeleteButton();
            }
            
            updateDeleteButton() {
                // Enable delete button if we have either a chunk selected or a valid selection
                const hasSelection = this.selection.start !== this.selection.end;
                const hasChunkSelected = this.selectedChunk !== null;
                this.deleteBtn.disabled = !(hasSelection || hasChunkSelected);
            }
            
            updateChunkOverlays() {
                // Clear existing overlays
                this.chunkOverlays.forEach(overlay => overlay.remove());
                this.chunkOverlays = [];
                
                // Only create overlays if there's more than one chunk
                if (this.chunks.length <= 1) {
                    return;
                }
                
                // Calculate total duration of all chunks for proportional positioning
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4; // pixels between chunks (same as in drawWaveform)
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const waveformWidth = this.waveform.getBoundingClientRect().width;
                const availableWidth = waveformWidth - totalGaps;
                
                let currentX = 0;
                
                // Create overlays for each chunk
                this.chunks.forEach(chunk => {
                    const overlay = document.createElement('div');
                    overlay.className = 'chunk-overlay';
                    
                    if (this.selectedChunk && chunk.id === this.selectedChunk.id) {
                        overlay.classList.add('selected');
                    }
                    
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidthPixels = availableWidth * chunkWidthRatio;
                    
                    overlay.style.left = (currentX / waveformWidth * 100) + '%';
                    overlay.style.width = (chunkWidthPixels / waveformWidth * 100) + '%';
                    
                    // Add hover effect
                    overlay.addEventListener('mouseenter', () => {
                        if (!overlay.classList.contains('selected')) {
                            overlay.classList.add('hovered');
                        }
                    });
                    
                    overlay.addEventListener('mouseleave', () => {
                        overlay.classList.remove('hovered');
                    });
                    
                    this.waveform.appendChild(overlay);
                    this.chunkOverlays.push(overlay);
                    
                    // Move to next chunk position (add gap)
                    currentX += chunkWidthPixels + gapWidth;
                });
            }
            
            updateChunkInfo() {
                this.chunkCount.textContent = this.chunks.length;
                
                if (this.selectedChunk) {
                    const duration = this.selectedChunk.end - this.selectedChunk.start;
                    const info = `Chunk ${this.selectedChunk.id + 1} | ${this.formatTime(this.selectedChunk.start)} - ${this.formatTime(this.selectedChunk.end)} | Duration: ${this.formatTime(duration)}`;
                    this.selectedChunkInfo.textContent = info;
                    this.chunkInfo.style.display = 'block';
                } else {
                    this.chunkInfo.style.display = 'none';
                }
            }
            
            splitAtPosition() {
                if (!this.audioBuffer) return;
                
                const splitTime = this.seekPosition;
                
                // Find the chunk that contains the split position
                const chunkIndex = this.chunks.findIndex(chunk => 
                    splitTime > chunk.start && splitTime < chunk.end
                );
                
                if (chunkIndex === -1) {
                    alert('Split position must be within an existing chunk');
                    return;
                }
                
                const originalChunk = this.chunks[chunkIndex];
                
                // Create two new chunks
                const leftChunk = {
                    start: originalChunk.start,
                    end: splitTime,
                    id: this.nextChunkId++
                };
                
                const rightChunk = {
                    start: splitTime,
                    end: originalChunk.end,
                    id: this.nextChunkId++
                };
                
                // Replace the original chunk with the two new chunks
                this.chunks.splice(chunkIndex, 1, leftChunk, rightChunk);
                
                // Deselect any selected chunk
                this.selectedChunk = null;
                this.updateDeleteButton();
                
                // Update visual representation
                this.updateChunkOverlays();
                this.updateChunkInfo();
                this.drawWaveform();
            }
            
            // Common deletion function that actually removes audio data
            deleteAudioRange(startTime, endTime) {
                if (!this.audioBuffer) return;
                
                const sampleRate = this.audioBuffer.sampleRate;
                const channels = this.audioBuffer.numberOfChannels;
                
                // Calculate the samples to remove
                const startSample = Math.floor(startTime * sampleRate);
                const endSample = Math.floor(endTime * sampleRate);
                const samplesToDelete = endSample - startSample;
                
                // Create new buffer without the deleted portion
                const newLength = this.audioBuffer.length - samplesToDelete;
                const newBuffer = this.audioContext.createBuffer(channels, newLength, sampleRate);
                
                // Copy audio data, skipping the deleted range
                for (let channel = 0; channel < channels; channel++) {
                    const oldData = this.audioBuffer.getChannelData(channel);
                    const newData = newBuffer.getChannelData(channel);
                    
                    // Copy before deleted range
                    for (let i = 0; i < startSample; i++) {
                        newData[i] = oldData[i];
                    }
                    
                    // Copy after deleted range
                    for (let i = endSample; i < oldData.length; i++) {
                        newData[i - samplesToDelete] = oldData[i];
                    }
                }
                
                // Update audio buffer
                this.audioBuffer = newBuffer;
                
                // Update all chunk times that come after the deleted range
                const deleteDuration = endTime - startTime;
                this.chunks = this.chunks.map(chunk => {
                    if (chunk.start >= endTime) {
                        // Chunk is entirely after deleted range
                        return {
                            ...chunk,
                            start: chunk.start - deleteDuration,
                            end: chunk.end - deleteDuration
                        };
                    } else if (chunk.end <= startTime) {
                        // Chunk is entirely before deleted range
                        return chunk;
                    } else if (chunk.start >= startTime && chunk.end <= endTime) {
                        // Chunk is entirely within deleted range - mark for removal
                        return null;
                    } else if (chunk.start < startTime && chunk.end > endTime) {
                        // Deletion is within this chunk
                        return {
                            ...chunk,
                            end: chunk.end - deleteDuration
                        };
                    } else if (chunk.start < startTime && chunk.end > startTime) {
                        // Chunk partially overlaps start of deletion
                        return {
                            ...chunk,
                            end: startTime
                        };
                    } else if (chunk.start < endTime && chunk.end > endTime) {
                        // Chunk partially overlaps end of deletion
                        return {
                            ...chunk,
                            start: startTime,
                            end: chunk.end - deleteDuration
                        };
                    }
                    return chunk;
                }).filter(chunk => chunk !== null); // Remove deleted chunks
                
                // Regenerate waveform data for the new buffer
                this.generateWaveform();
                this.updateDuration();
                this.updateChunkOverlays();
                this.updateChunkInfo();
                
                // Reset playback position if it's in deleted range
                if (this.pausedAtTime >= startTime && this.pausedAtTime <= endTime) {
                    this.pausedAtTime = startTime;
                } else if (this.pausedAtTime > endTime) {
                    this.pausedAtTime -= deleteDuration;
                }
                
                this.seekPosition = this.pausedAtTime;
            }
            
            // Unified delete function
            delete() {
                // Determine what to delete - prioritize selection over chunk
                if (this.selection.start !== this.selection.end) {
                    // Delete selection
                    const startTime = Math.min(this.selection.start, this.selection.end);
                    const endTime = Math.max(this.selection.start, this.selection.end);
                    
                    this.deleteAudioRange(startTime, endTime);
                    
                    // Clear selection
                    this.selection.start = 0;
                    this.selection.end = 0;
                    this.selectionDiv.style.display = 'none';
                    
                } else if (this.selectedChunk) {
                    // Delete selected chunk
                    if (this.chunks.length <= 1) {
                        alert('Cannot delete chunk - at least one chunk must remain');
                        return;
                    }
                    
                    this.deleteAudioRange(this.selectedChunk.start, this.selectedChunk.end);
                    
                    // Clear chunk selection
                    this.selectedChunk = null;
                }
                
                this.updateDeleteButton();
                this.updateSelectionInfo();
            }
            
            handleMouseDown(event) {
                this.isDragging = true;
                this.dragStarted = false;
                
                const rect = this.waveform.getBoundingClientRect();
                const x = event.clientX - rect.left;
                
                // Calculate click time based on the new chunk layout
                const clickTime = this.getTimeFromPixelPosition(x);
                
                this.selection.start = clickTime;
                this.selection.end = clickTime;
                this.seekPosition = clickTime;
                
                // Enable split button only if we have a valid seek position in a chunk
                const seekChunk = this.chunks.find(chunk => 
                    clickTime >= chunk.start && clickTime <= chunk.end
                );
                this.splitBtn.disabled = !seekChunk;
                
                // Set initial position for potential drag
                this.initialClickTime = clickTime;
            }
            
            getTimeFromPixelPosition(pixelX) {
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4;
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const rect = this.waveform.getBoundingClientRect();
                const availableWidth = rect.width - totalGaps;
                
                let currentX = 0;
                
                // Find which chunk the pixel position is in
                for (const chunk of this.chunks) {
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidth = availableWidth * chunkWidthRatio;
                    
                    if (pixelX >= currentX && pixelX <= currentX + chunkWidth) {
                        // Calculate time within this chunk
                        const pixelInChunk = pixelX - currentX;
                        const progressInChunk = pixelInChunk / chunkWidth;
                        return chunk.start + (progressInChunk * chunkDuration);
                    }
                    
                    currentX += chunkWidth + gapWidth;
                }
                
                // If not in any chunk, return the closest chunk boundary
                return this.chunks.length > 0 ? this.chunks[0].start : 0;
            }
            
            handleMouseMove(event) {
                if (!this.isDragging) return;
                
                const rect = this.waveform.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const currentTime = this.getTimeFromPixelPosition(Math.max(0, Math.min(rect.width, x)));
                
                // Check if user has moved enough to start dragging (threshold to distinguish click from drag)
                if (!this.dragStarted && Math.abs(currentTime - this.initialClickTime) > 0.1) {
                    this.dragStarted = true;
                }
                
                if (this.dragStarted) {
                    // This is a drag operation - update selection
                    this.selection.end = currentTime;
                    this.updateSelectionDisplay();
                } else {
                    // Update seek position
                    this.seekPosition = currentTime;
                    this.drawWaveform();
                }
            }
            
            handleMouseUp() {
                if (!this.isDragging) return;
                
                if (!this.dragStarted) {
                    // This was a click, not a drag - seek to position
                    this.seekToTime(this.initialClickTime);
                    this.seekPosition = this.initialClickTime;
                    // Clear selection
                    this.selection.start = 0;
                    this.selection.end = 0;
                    this.selectionDiv.style.display = 'none';
                    this.updateSelectionInfo();
                    this.updateDeleteButton();
                } else {
                    // This was a drag - finalize selection
                    this.endSelection();
                }
                
                this.isDragging = false;
                this.dragStarted = false;
            }
            
            async seekToTime(time) {
                // Clamp time to valid range
                time = Math.max(0, Math.min(time, this.audioBuffer.duration));
                
                const wasPlaying = this.isPlaying;
                
                // Stop current playback
                if (this.isPlaying) {
                    this.source.stop();
                    this.isPlaying = false;
                }
                
                // Update paused time to the clicked position
                this.pausedAtTime = time;
                this.seekPosition = time;
                
                // Redraw waveform to show new position
                this.drawWaveform();
                
                // If audio was playing, resume from new position
                if (wasPlaying) {
                    await this.play();
                }
            }
            
            async initializeAudioContext() {
                if (this.audioContext) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Handle suspended state
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    this.isInitialized = true;
                    console.log('AudioContext initialized:', this.audioContext.state);
                } catch (error) {
                    console.error('Audio context not supported:', error);
                    throw error;
                }
            }
            
            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.handleFile(file);
                }
            }
            
            async handleFile(file) {
                if (!file.type.startsWith('audio/')) {
                    alert('Please select an audio file');
                    return;
                }
                
                this.originalFile = file;
                this.progress.style.display = 'block';
                this.updateProgress(0);
                
                try {
                    // Initialize audio context first
                    await this.initializeAudioContext();
                    this.updateProgress(20);
                    
                    const arrayBuffer = await file.arrayBuffer();
                    this.updateProgress(50);
                    
                    this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.updateProgress(75);
                    
                    // Reset playback state
                    this.pausedAtTime = 0;
                    this.seekPosition = 0;
                    this.isPlaying = false;
                    this.selection = { start: 0, end: 0 };
                    
                    // Initialize chunks
                    this.chunks = [{ start: 0, end: this.audioBuffer.duration, id: 0 }];
                    this.selectedChunk = null;
                    this.nextChunkId = 1;
                    
                    // Show container first, then generate waveform
                    this.waveformContainer.style.display = 'block';
                    
                    // Use requestAnimationFrame to ensure DOM is updated
                    requestAnimationFrame(() => {
                        this.generateWaveform();
                        this.updateProgress(100);
                        
                        this.updateDuration();
                        this.updateCurrentTime();
                        this.updateChunkInfo();
                        this.updateDeleteButton();
                        this.enableControls();
                        
                        setTimeout(() => {
                            this.progress.style.display = 'none';
                        }, 500);
                    });
                    
                } catch (error) {
                    console.error('Error processing audio file:', error);
                    alert('Error processing audio file. Please try another file.');
                    this.progress.style.display = 'none';
                }
            }
            
            updateProgress(percent) {
                this.progressBar.style.width = percent + '%';
            }
            
            generateWaveform() {
                const channelData = this.audioBuffer.getChannelData(0);
                const samples = Math.floor(channelData.length / 1000);
                this.waveformData = [];
                
                for (let i = 0; i < 1000; i++) {
                    const start = Math.floor(i * samples);
                    const end = Math.floor((i + 1) * samples);
                    let max = 0;
                    
                    for (let j = start; j < end; j++) {
                        const sample = Math.abs(channelData[j]);
                        if (sample > max) max = sample;
                    }
                    
                    this.waveformData.push(max);
                }
                
                // Force canvas resize and redraw
                this.resizeCanvas();
                
                // Use another requestAnimationFrame to ensure canvas is properly sized
                requestAnimationFrame(() => {
                    this.drawWaveform();
                    this.updateChunkOverlays();
                });
            }
            
            resizeCanvas() {
                if (!this.canvas || !this.waveform) return;
                
                // Get actual dimensions
                const rect = this.waveform.getBoundingClientRect();
                
                // Ensure we have valid dimensions
                if (rect.width <= 0 || rect.height <= 0) {
                    // Try again after a short delay
                    setTimeout(() => this.resizeCanvas(), 10);
                    return;
                }
                
                // Set canvas size
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // Force style update
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                console.log('Canvas resized to:', rect.width, 'x', rect.height);
                
                // Redraw if we have waveform data
                if (this.waveformData) {
                    this.drawWaveform();
                }
            }
            
            drawWaveform() {
                if (!this.waveformData || !this.canvas || this.canvas.width <= 0 || this.canvas.height <= 0) {
                    console.warn('Cannot draw waveform - invalid state');
                    return;
                }
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, width, height);
                
                // Calculate total duration of all chunks for proportional rendering
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4; // pixels between chunks
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const availableWidth = width - totalGaps;
                
                let currentX = 0;
                
                // Draw each chunk separately with gaps
                this.chunks.forEach((chunk, chunkIndex) => {
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidth = availableWidth * chunkWidthRatio;
                    
                    // Calculate which part of the original waveform this chunk represents
                    const chunkStartRatio = chunk.start / this.audioBuffer.duration;
                    const chunkEndRatio = chunk.end / this.audioBuffer.duration;
                    const startSample = Math.floor(chunkStartRatio * this.waveformData.length);
                    const endSample = Math.ceil(chunkEndRatio * this.waveformData.length);
                    const chunkSamples = endSample - startSample;
                    
                    if (chunkSamples > 0) {
                        const barWidth = chunkWidth / chunkSamples;
                        
                        // Draw this chunk's waveform
                        for (let i = 0; i < chunkSamples; i++) {
                            const sampleIndex = startSample + i;
                            if (sampleIndex < this.waveformData.length) {
                                this.ctx.fillStyle = '#4CAF50';
                                
                                const barHeight = this.waveformData[sampleIndex] * height * 0.8;
                                const x = currentX + (i * barWidth);
                                const y = (height - barHeight) / 2;
                                
                                // Ensure minimum bar height for visibility
                                const minHeight = Math.max(2, barHeight);
                                const actualBarWidth = Math.max(1, barWidth - 0.5);
                                
                                this.ctx.fillRect(x, y, actualBarWidth, minHeight);
                            }
                        }
                    }
                    
                    // Move to next chunk position (add gap)
                    currentX += chunkWidth + gapWidth;
                });
                
                // Draw playback progress line
                this.drawProgressLine();
                
                // Draw seek position line
                this.drawSeekLine();
                
                console.log('Waveform drawn successfully');
            }
            
            drawChunkBoundaries() {
                if (!this.audioBuffer) return;
                
                this.ctx.strokeStyle = '#FF6B6B';
                this.ctx.lineWidth = 2;
                
                // Draw vertical lines at chunk boundaries
                this.chunks.forEach(chunk => {
                    if (chunk.start > 0) {
                        const x = (chunk.start / this.audioBuffer.duration) * this.canvas.width;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.height);
                        this.ctx.stroke();
                    }
                    if (chunk.end < this.audioBuffer.duration) {
                        const x = (chunk.end / this.audioBuffer.duration) * this.canvas.width;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, 0);
                        this.ctx.lineTo(x, this.canvas.height);
                        this.ctx.stroke();
                    }
                });
            }
            
            drawProgressLine() {
                if (!this.audioBuffer) return;
                
                const currentTime = this.getCurrentPlaybackTime();
                
                // Find which chunk contains the current time
                const currentChunk = this.chunks.find(chunk => 
                    currentTime >= chunk.start && currentTime <= chunk.end
                );
                
                if (!currentChunk) return; // Don't draw if not in any chunk
                
                // Calculate position within the chunk layout
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4;
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const availableWidth = this.canvas.width - totalGaps;
                
                let currentX = 0;
                let progressX = 0;
                
                // Find the position for the current chunk
                for (const chunk of this.chunks) {
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidth = availableWidth * chunkWidthRatio;
                    
                    if (chunk.id === currentChunk.id) {
                        // Calculate position within this chunk
                        const timeInChunk = currentTime - chunk.start;
                        const progressInChunk = timeInChunk / chunkDuration;
                        progressX = currentX + (progressInChunk * chunkWidth);
                        break;
                    }
                    
                    currentX += chunkWidth + gapWidth;
                }
                
                this.ctx.strokeStyle = '#FFD700';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(progressX, 0);
                this.ctx.lineTo(progressX, this.canvas.height);
                this.ctx.stroke();
            }
            
            drawSeekLine() {
                if (!this.audioBuffer) return;
                
                // Find which chunk contains the seek position
                const seekChunk = this.chunks.find(chunk => 
                    this.seekPosition >= chunk.start && this.seekPosition <= chunk.end
                );
                
                if (!seekChunk) return; // Don't draw if not in any chunk
                
                // Calculate position within the chunk layout
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4;
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const availableWidth = this.canvas.width - totalGaps;
                
                let currentX = 0;
                let seekX = 0;
                
                // Find the position for the seek chunk
                for (const chunk of this.chunks) {
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidth = availableWidth * chunkWidthRatio;
                    
                    if (chunk.id === seekChunk.id) {
                        // Calculate position within this chunk
                        const timeInChunk = this.seekPosition - chunk.start;
                        const progressInChunk = timeInChunk / chunkDuration;
                        seekX = currentX + (progressInChunk * chunkWidth);
                        break;
                    }
                    
                    currentX += chunkWidth + gapWidth;
                }
                
                this.ctx.strokeStyle = '#FF6B6B';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(seekX, 0);
                this.ctx.lineTo(seekX, this.canvas.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]); // Reset line dash
            }
            
            getCurrentPlaybackTime() {
                if (!this.isPlaying) return this.pausedAtTime;
                return this.pausedAtTime + (this.audioContext.currentTime - this.playStartTime);
            }
            
            endSelection() {
                this.isDragging = false;
                if (this.selection.start > this.selection.end) {
                    [this.selection.start, this.selection.end] = [this.selection.end, this.selection.start];
                }
                
                // Validate that selection is within existing chunks
                const startInChunk = this.chunks.some(chunk => 
                    this.selection.start >= chunk.start && this.selection.start <= chunk.end
                );
                const endInChunk = this.chunks.some(chunk => 
                    this.selection.end >= chunk.start && this.selection.end <= chunk.end
                );
                
                if (!startInChunk || !endInChunk) {
                    // Clear invalid selection
                    this.selection.start = 0;
                    this.selection.end = 0;
                    this.selectionDiv.style.display = 'none';
                }
                
                this.updateSelectionInfo();
                this.updateSelectionDisplay();
                this.updateDeleteButton();
            }
            
            updateSelectionDisplay() {
                if (!this.audioBuffer || this.chunks.length === 0) return;
                
                // Calculate selection position based on chunk layout
                const totalChunkDuration = this.chunks.reduce((sum, chunk) => sum + (chunk.end - chunk.start), 0);
                const gapWidth = 4; // pixels between chunks
                const totalGaps = Math.max(0, this.chunks.length - 1) * gapWidth;
                const rect = this.waveform.getBoundingClientRect();
                const availableWidth = rect.width - totalGaps;
                
                let selectionStartX = null;
                let selectionEndX = null;
                let currentX = 0;
                
                // Find pixel positions for selection start and end
                for (const chunk of this.chunks) {
                    const chunkDuration = chunk.end - chunk.start;
                    const chunkWidthRatio = chunkDuration / totalChunkDuration;
                    const chunkWidth = availableWidth * chunkWidthRatio;
                    
                    // Check if selection start is in this chunk
                    if (selectionStartX === null && this.selection.start >= chunk.start && this.selection.start <= chunk.end) {
                        const timeInChunk = this.selection.start - chunk.start;
                        const progressInChunk = timeInChunk / chunkDuration;
                        selectionStartX = currentX + (progressInChunk * chunkWidth);
                    }
                    
                    // Check if selection end is in this chunk
                    if (selectionEndX === null && this.selection.end >= chunk.start && this.selection.end <= chunk.end) {
                        const timeInChunk = this.selection.end - chunk.start;
                        const progressInChunk = timeInChunk / chunkDuration;
                        selectionEndX = currentX + (progressInChunk * chunkWidth);
                    }
                    
                    currentX += chunkWidth + gapWidth;
                }
                
                // Only show selection if both start and end are within valid chunks
                if (selectionStartX !== null && selectionEndX !== null) {
                    const leftX = Math.min(selectionStartX, selectionEndX);
                    const rightX = Math.max(selectionStartX, selectionEndX);
                    
                    this.selectionDiv.style.left = (leftX / rect.width * 100) + '%';
                    this.selectionDiv.style.width = ((rightX - leftX) / rect.width * 100) + '%';
                    this.selectionDiv.style.display = 'block';
                } else {
                    // Hide selection if it spans deleted chunks or is outside valid chunks
                    this.selectionDiv.style.display = 'none';
                }
            }
            
            updateSelectionInfo() {
                if (this.selection.start === this.selection.end) {
                    this.selectionInfo.textContent = 'No selection';
                    this.cropBtn.disabled = true;
                    return;
                }
                
                // Check if selection is valid (both points in existing chunks)
                const startInChunk = this.chunks.some(chunk => 
                    this.selection.start >= chunk.start && this.selection.start <= chunk.end
                );
                const endInChunk = this.chunks.some(chunk => 
                    this.selection.end >= chunk.start && this.selection.end <= chunk.end
                );
                
                if (!startInChunk || !endInChunk) {
                    this.selectionInfo.textContent = 'Selection spans deleted chunks';
                    this.cropBtn.disabled = true;
                    return;
                }
                
                const start = this.formatTime(this.selection.start);
                const end = this.formatTime(this.selection.end);
                const duration = this.formatTime(Math.abs(this.selection.end - this.selection.start));
                this.selectionInfo.textContent = `${start} - ${end} (${duration})`;
                this.cropBtn.disabled = false;
            }
            
            updateDuration() {
                this.durationSpan.textContent = this.formatTime(this.audioBuffer.duration);
            }
            
            updateCurrentTime() {
                if (!this.audioBuffer) return;
                const currentTime = this.getCurrentPlaybackTime();
                this.currentTimeSpan.textContent = this.formatTime(currentTime);
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            enableControls() {
                this.playBtn.disabled = false;
                this.pauseBtn.disabled = false;
                this.stopBtn.disabled = false;
            }
            
            async play() {
                if (this.isPlaying) return;
                
                // Resume audio context if suspended
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                if (this.selectedChunk) {
                    // Play only the selected chunk
                    this.playChunk(this.selectedChunk);
                } else {
                    // Play all remaining chunks in sequence
                    this.playAllChunks();
                }
            }
            
            async playChunk(chunk) {
                this.source = this.audioContext.createBufferSource();
                const chunkBuffer = this.createChunkBuffer(chunk);
                this.source.buffer = chunkBuffer;
                this.source.connect(this.audioContext.destination);
                
                // Calculate start position within the chunk
                let startOffset = 0;
                if (this.pausedAtTime >= chunk.start && this.pausedAtTime <= chunk.end) {
                    startOffset = this.pausedAtTime - chunk.start;
                }
                
                this.source.start(0, startOffset);
                this.playStartTime = this.audioContext.currentTime;
                this.pausedAtTime = chunk.start + startOffset;
                this.isPlaying = true;
                this.currentlyPlayingChunk = chunk;
                
                this.playBtn.textContent = '‚è∏Ô∏è Playing...';
                this.pauseBtn.disabled = false;
                
                // Start animation loop
                this.animateProgress();
                
                // Auto-stop when chunk ends
                this.source.onended = () => {
                    if (this.isPlaying) {
                        this.stop();
                    }
                };
            }
            
            async playAllChunks() {
                if (this.chunks.length === 0) {
                    this.stop();
                    return;
                }
                
                // Sort chunks by start time
                const sortedChunks = [...this.chunks].sort((a, b) => a.start - b.start);
                
                // Find which chunk to start from based on pausedAtTime
                let startChunkIndex = 0;
                let startOffset = 0;
                
                for (let i = 0; i < sortedChunks.length; i++) {
                    const chunk = sortedChunks[i];
                    if (this.pausedAtTime >= chunk.start && this.pausedAtTime <= chunk.end) {
                        startChunkIndex = i;
                        startOffset = this.pausedAtTime - chunk.start;
                        break;
                    } else if (this.pausedAtTime < chunk.start) {
                        startChunkIndex = i;
                        startOffset = 0;
                        this.pausedAtTime = chunk.start;
                        break;
                    }
                }
                
                // Create a combined buffer from all remaining chunks
                const combinedBuffer = this.createCombinedChunksBuffer(sortedChunks, startChunkIndex, startOffset);
                
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = combinedBuffer;
                this.source.connect(this.audioContext.destination);
                this.source.start(0);
                
                this.playStartTime = this.audioContext.currentTime;
                this.isPlaying = true;
                this.currentlyPlayingChunk = null; // Playing multiple chunks
                this.playingChunks = sortedChunks.slice(startChunkIndex);
                this.playingStartOffset = startOffset;
                
                this.playBtn.textContent = '‚è∏Ô∏è Playing...';
                this.pauseBtn.disabled = false;
                
                // Start animation loop
                this.animateProgress();
                
                // Auto-stop when audio ends
                this.source.onended = () => {
                    if (this.isPlaying) {
                        this.stop();
                    }
                };
            }
            
            createCombinedChunksBuffer(sortedChunks, startChunkIndex = 0, startOffset = 0) {
                if (sortedChunks.length === 0) return null;
                
                const sampleRate = this.audioBuffer.sampleRate;
                const channels = this.audioBuffer.numberOfChannels;
                
                // Calculate total duration from startChunkIndex onwards
                let totalDuration = 0;
                for (let i = startChunkIndex; i < sortedChunks.length; i++) {
                    const chunk = sortedChunks[i];
                    const chunkDuration = chunk.end - chunk.start;
                    if (i === startChunkIndex) {
                        totalDuration += chunkDuration - startOffset;
                    } else {
                        totalDuration += chunkDuration;
                    }
                }
                
                const totalFrames = Math.floor(totalDuration * sampleRate);
                const combinedBuffer = this.audioContext.createBuffer(channels, totalFrames, sampleRate);
                
                let currentFrame = 0;
                
                // Copy audio data from chunks
                for (let i = startChunkIndex; i < sortedChunks.length; i++) {
                    const chunk = sortedChunks[i];
                    const chunkStartTime = i === startChunkIndex ? chunk.start + startOffset : chunk.start;
                    const chunkEndTime = chunk.end;
                    
                    const startFrame = Math.floor(chunkStartTime * sampleRate);
                    const endFrame = Math.floor(chunkEndTime * sampleRate);
                    const chunkFrames = endFrame - startFrame;
                    
                    for (let channel = 0; channel < channels; channel++) {
                        const oldData = this.audioBuffer.getChannelData(channel);
                        const newData = combinedBuffer.getChannelData(channel);
                        
                        for (let j = 0; j < chunkFrames; j++) {
                            if (currentFrame + j < totalFrames) {
                                newData[currentFrame + j] = oldData[startFrame + j] || 0;
                            }
                        }
                    }
                    currentFrame += chunkFrames;
                }
                
                return combinedBuffer;
            }
            
            createChunkBuffer(chunk) {
                const sampleRate = this.audioBuffer.sampleRate;
                const channels = this.audioBuffer.numberOfChannels;
                const startFrame = Math.floor(chunk.start * sampleRate);
                const endFrame = Math.floor(chunk.end * sampleRate);
                const frameCount = endFrame - startFrame;
                
                const chunkBuffer = this.audioContext.createBuffer(channels, frameCount, sampleRate);
                
                // Copy audio data for the chunk
                for (let channel = 0; channel < channels; channel++) {
                    const oldData = this.audioBuffer.getChannelData(channel);
                    const newData = chunkBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < frameCount; i++) {
                        newData[i] = oldData[startFrame + i] || 0;
                    }
                }
                
                return chunkBuffer;
            }
            
            animateProgress() {
                if (!this.isPlaying) return;
                
                this.drawWaveform();
                this.updateCurrentTime();
                requestAnimationFrame(() => this.animateProgress());
            }
            
            pause() {
                if (!this.isPlaying) return;
                
                this.source.stop();
                
                // Update paused time based on current playback position
                this.pausedAtTime = this.getCurrentPlaybackTime();
                
                this.isPlaying = false;
                this.currentlyPlayingChunk = null;
                this.playingChunks = null;
                this.playBtn.textContent = '‚ñ∂Ô∏è Play';
                this.pauseBtn.disabled = true;
                
                // Redraw waveform with progress line at paused position
                this.drawWaveform();
                this.updateCurrentTime();
            }
            
            stop() {
                if (this.source) {
                    this.source.stop();
                }
                this.isPlaying = false;
                this.currentlyPlayingChunk = null;
                this.playingChunks = null;
                
                // Reset to beginning of first chunk or selected chunk
                if (this.selectedChunk) {
                    this.pausedAtTime = this.selectedChunk.start;
                } else if (this.chunks.length > 0) {
                    const firstChunk = [...this.chunks].sort((a, b) => a.start - b.start)[0];
                    this.pausedAtTime = firstChunk.start;
                } else {
                    this.pausedAtTime = 0;
                }
                
                this.playBtn.textContent = '‚ñ∂Ô∏è Play';
                this.pauseBtn.disabled = true;
                
                // Redraw waveform with progress line at stop position
                this.drawWaveform();
                this.updateCurrentTime();
            }
            
            async cropAudio() {
                if (this.selection.start === this.selection.end) {
                    alert('Please select a portion of the audio to crop');
                    return;
                }
                
                try {
                    const start = Math.min(this.selection.start, this.selection.end);
                    const end = Math.max(this.selection.start, this.selection.end);
                    
                    // Show progress
                    this.cropBtn.textContent = 'üîÑ Processing...';
                    this.cropBtn.disabled = true;
                    
                    // Create new audio buffer with selected portion
                    const sampleRate = this.audioBuffer.sampleRate;
                    const channels = this.audioBuffer.numberOfChannels;
                    const startFrame = Math.floor(start * sampleRate);
                    const endFrame = Math.floor(end * sampleRate);
                    const frameCount = endFrame - startFrame;
                    
                    const newBuffer = this.audioContext.createBuffer(channels, frameCount, sampleRate);
                    
                    // Copy audio data
                    for (let channel = 0; channel < channels; channel++) {
                        const oldData = this.audioBuffer.getChannelData(channel);
                        const newData = newBuffer.getChannelData(channel);
                        
                        for (let i = 0; i < frameCount; i++) {
                            newData[i] = oldData[startFrame + i] || 0;
                        }
                    }
                    
                    // Convert to WAV
                    const wavArrayBuffer = this.audioBufferToWav(newBuffer);
                    const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });
                    
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `cropped_audio_${start.toFixed(1)}s-${end.toFixed(1)}s.wav`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    // Cleanup
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    this.cropBtn.textContent = 'üìè Crop Selection';
                    this.cropBtn.disabled = false;
                    
                    console.log(`Cropped audio: ${start.toFixed(2)}s to ${end.toFixed(2)}s`);
                    
                } catch (error) {
                    console.error('Error cropping audio:', error);
                    alert('Error cropping audio. Please try again.');
                    this.cropBtn.textContent = 'üìè Crop Selection';
                    this.cropBtn.disabled = false;
                }
            }
            
            async exportRemainingChunks() {
                if (this.chunks.length === 0) {
                    alert('No chunks to export');
                    return;
                }
                
                try {
                    // Calculate total duration of remaining chunks
                    let totalDuration = 0;
                    this.chunks.forEach(chunk => {
                        totalDuration += (chunk.end - chunk.start);
                    });
                    
                    const sampleRate = this.audioBuffer.sampleRate;
                    const channels = this.audioBuffer.numberOfChannels;
                    const totalFrames = Math.floor(totalDuration * sampleRate);
                    
                    const newBuffer = this.audioContext.createBuffer(channels, totalFrames, sampleRate);
                    
                    // Copy audio data from all chunks
                    let currentFrame = 0;
                    for (const chunk of this.chunks) {
                        const startFrame = Math.floor(chunk.start * sampleRate);
                        const endFrame = Math.floor(chunk.end * sampleRate);
                        const chunkFrames = endFrame - startFrame;
                        
                        for (let channel = 0; channel < channels; channel++) {
                            const oldData = this.audioBuffer.getChannelData(channel);
                            const newData = newBuffer.getChannelData(channel);
                            
                            for (let i = 0; i < chunkFrames; i++) {
                                newData[currentFrame + i] = oldData[startFrame + i] || 0;
                            }
                        }
                        currentFrame += chunkFrames;
                    }
                    
                    // Convert to WAV and download
                    const wavArrayBuffer = this.audioBufferToWav(newBuffer);
                    const blob = new Blob([wavArrayBuffer], { type: 'audio/wav' });
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `edited_audio_${this.chunks.length}_chunks.wav`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                } catch (error) {
                    console.error('Error exporting chunks:', error);
                    alert('Error exporting audio. Please try again.');
                }
            }
            
            audioBufferToWav(buffer) {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const bitsPerSample = 16;
                const bytesPerSample = bitsPerSample / 8;
                const blockAlign = numberOfChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = length * blockAlign;
                const fileSize = 44 + dataSize;
                
                const arrayBuffer = new ArrayBuffer(fileSize);
                const view = new DataView(arrayBuffer);
                
                // Helper function to write string to DataView
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                // Write WAV header
                writeString(0, 'RIFF');                          // ChunkID
                view.setUint32(4, fileSize - 8, true);          // ChunkSize
                writeString(8, 'WAVE');                          // Format
                writeString(12, 'fmt ');                         // Subchunk1ID
                view.setUint32(16, 16, true);                   // Subchunk1Size (PCM)
                view.setUint16(20, 1, true);                    // AudioFormat (PCM)
                view.setUint16(22, numberOfChannels, true);     // NumChannels
                view.setUint32(24, sampleRate, true);           // SampleRate
                view.setUint32(28, byteRate, true);             // ByteRate
                view.setUint16(32, blockAlign, true);           // BlockAlign
                view.setUint16(34, bitsPerSample, true);        // BitsPerSample
                writeString(36, 'data');                         // Subchunk2ID
                view.setUint32(40, dataSize, true);             // Subchunk2Size
                
                // Write audio data
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        // Convert float32 (-1 to 1) to int16 (-32768 to 32767)
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        const int16Sample = Math.round(sample * 32767);
                        view.setInt16(offset, int16Sample, true);
                        offset += 2;
                    }
                }
                
                return arrayBuffer;
            }
        }
        
        // Initialize the audio chunking editor when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AudioChunkingEditor();
        });
    </script>
</body>
</html>
